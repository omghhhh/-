
//*******************************************引入头文件*********************************************
#include "stdafx.h"

//自定义符号常量
#define DestoryList ClearList  //两函数操作是一样的
#define OVERFLOW -2 //内存溢出错误常量
#define ILLEGAL -1
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0

//自定义数据类型
typedef char ElemType; //元素类型
typedef int Status;    //状态参数类型

//线性表的静态单链表存储结构
#define MAXSIZE 1000 //链表的最大长度
typedef struct{
	ElemType Data;  //数据域
	int cur;        //游标，相当于指针域，存放下一个节点在数据中的位置下标
}component,SLinkList[MAXSIZE];

//***************************************线性静态单链表的主要操作****************************************** 

/*
函数：Malloc
参数：SLinkList L 静态链表首地址
返回值：新开辟结点的坐标
作用：（申请结点空间）若备用空间链表非空，从备用链表取出一个空闲结点
并返回该结点下标，否则返回0
*/
int Malloc(SLinkList L){
	//L[0].cur记录了备用链表第一个空闲节点在数组中的位置
	int i = L[0].cur;
	//cur的值为0相当于指针域为NULL
	//cur的值为0表示该节点没有后继，该节点是链表中的最后一个节点
	//i的值不为0表示备用链表还有空闲节点可以使用
	if (i){
		//备用链表（即没有存储数据的那些结点）的头节点指向原备用链表的第二个节点
		//i（也就是L[0].cur)指向了第一个空闲节点的位置
		//所以L[i].cur指向了第二个空闲节点的位置
		//L[0].cur是备用链表的头节点，所以L[0].cur = L[i].cur;这句代码的意思就是从备用链表把第一个空闲节点取走
		//然后把第二个空闲节点挂在备用链表的头节点上
		L[0].cur = L[i].cur;
	}
	//返回新开辟的节点坐标
	return i;
}//Malloc

/*
函数：InitList
参数：SLinkList L 静态链表首地址
返回值：空表在数组中的位序
作用：构造一个空链表
*/
int InitList(SLinkList L){
	//注意：此时一个数组中存了两个链表：静态链表数据存储区域和备用链表
	//静态链表在的头结点在数组中的位置就是i，但i不是0，因为0号单元已经规定
	//就是备用链表的头结点。所以L[i].cur是静态链表的首元结点。
	//而备用链表的头结点是L[0]，首元结点在数组中的位置是L[0].cur
	//由于一个数组中要同时存储两个链表，所以要区分开静态链表数据存储区域和备用链表，
	//尤其要区分开两者的头结点（第一个元素结点之前设置的一个结点）和首元结点（第一个有数据元素的结点）的不同。
	//而且要注意，由于静态链表数据存储链表的头结点是从备用链表上取出来的，位置不固定
	//所以在调用的时候要用变量保存头结点在数组中的位置，否则后续操作将无法进行

	int i;

	//i存储了新开辟结点的坐标 
	i = Malloc(L);

	//由于静态链表刚刚初始化，除了头结点一个数据结点都没有，所以要把
	//静态链表头结点的指针域【也就是cur】设置为0，意思是后面没有后继节点
	L[i].cur = 0;

	//新开辟的第一个结点就是静态链表的头结点，头结点位置是i
	return i;
}//InitList

/*
函数：InitSpace
参数：SLinkList L 静态链表首地址
返回值：无
作用：（初始化备用空间）将一维数组L中各分量链成一个备用链表，
L[0].cur为头指针，"0"代表空指针
这个函数是用来初始化备用链表的，不是用来初始化静态链表的数据存储区域
*/
void InitSpace(SLinkList L){

	//此时静态链表还未投入使用，所以整个数组都是备用链表的空间
	for (int i = 0; i < MAXSIZE - 1; ++i){

		//将第i+1个元素的下标（相对地址）存在第i个元素的cur中
		L[i].cur = i + 1;
	}//for

	//最后一个元素的cur存放0，表示空指针，即该位置为备用链表表尾
	L[MAXSIZE - 1].cur = 0;
}//InitSpace
